# 17jun14jk

(let (Goods 0 Bads 0)
	(mapc
		'((BoolExpr)
			(if (eval BoolExpr)
				(inc 'Goods)
				(inc 'Bads) (println 'Error: BoolExpr 'Result: (eval (caddr BoolExpr))) ) )
		(list
			'(= '(NIL) (list))
			'(= T (= "abc" "abc"))
			'(= 0 (let N 0 (= 1 2 (inc 'N)) N))
			'(= 0 (let N 0 (== 1 2 (inc 'N)) N))
			'(= -7 (- (+ 3 4)))
			'(= 4 (- (+ 3 4) 2 1))
			'(= T (< NIL 12 13 'X "Y" (9 9) (9 9 NIL) T))
			'(= T (> T (1 2 (3 . 4)) (1 2 (3)) "Y" 'X 13 12 NIL))
			'(= NIL (< NIL T 12))
			'(= NIL (< 12 14 14))
			'(= T (<= 12 13 13 14 'X 'X 'Y))
			'(= NIL (<= 12 14 13))
			'(= T (<= (usec) (usec)))
			'(= T (<> 2 2 3))
			'(= NIL (<> 2 2 2))
			'(= '(NIL NIL 0 3) (mapcar ge0 (list 'foo -1 (- 2 2) 3)))
			'(= '(NIL NIL 1 3) (mapcar gt0 (list 'foo -1 (- 3 2) 3)))
			'(= '(NIL -1 0 NIL) (mapcar le0 (list 'foo -1 (- 2 2) 3)))
			'(= '(NIL -1 NIL NIL) (mapcar lt0 (list 'foo -1 (- 2 2) 3)))
			'(= '(T T NIL T) (mapcar n0 (list 'foo -1 (- 2 2) 3)))
			'(= '(NIL NIL 0 NIL) (mapcar =0 (list 'foo -1 (- 2 2) 3)))
			'(= T (=T (= 2 2)))
			'(= NIL (=T 0))
			'(= 0 (prog (zero N) (= 1 2 (inc 'N)) N))
			'(= 0 (prog (zero N) (== 1 2 (inc 'N)) N))
			'(= "1two3T9" (pack 1 "two" (3 T) NIL (+ 4 5)))
			'(= NIL (pack ""))
			'(= 6 (eval (list '+ 1 2 3)))
			'(= "BCDC" (prog (setq A 'B B 'C C 'D) (pack A B C (eval A))))
			#'(= "BCDC" (let ("A" "B" "B" "C" "C" "D") (pack "A" "B" "C" (eval "A"))))
			'(= "BCDC" (prog (setq "A" '"B" "B" '"C" "C" '"D") (pack "A" "B" "C" (eval "A"))))
			'(= T (prog (setq "A" '"B") (= "A" 'B)))
			'(= 3 (fin (1 2 . 3)))
			'(= NIL (fin (1 2 3)))
			'(= (7 3) (list (if 3 (+ @ 4) 9) @))
			'(= 15 (if 5 (if NIL 88 'dummy1 'dummy2 (+ @ 10)) 99))
			'(= 15 (ifn 5 99 (ifn NIL (+ @ 10) 'dummy1 88)))
			'(= 120 (prog (de fact (N) (if (= 0 N) 1 (* N (fact (- N 1))))) (fact 5)))
			'(= '(a b) (prog (de f1 X (list (car X) (cadr X))) (f1 a b)))
			#'(= (3 7 ((+ 5 6) (+ 7 8))) (prog (de f2 (X Y . Z) (list X Y Z)) (f2 (+ 1 2) (+ 3 4) (+ 5 6) (+ 7 8))))
			'(= 3 (for X (1 2 3 4) (= X 0) (T (= X 3) 'foo X) 'dummy))
			'(= 3 (for X (1 2 3 4) (= X 0) (NIL (not (= X 3)) 'foo X) 'dummy))
			'(= 3 (for (N 1 (not (= N 4)) (inc N)) N))
			'(= (3 13) (for ((I . N) 11 (not (= I 4)) (inc N)) (list I N)))
			'(= (5 4 3 2 1) (make (for (N 1 (<= N 5) (inc N)) (yoke N))))
			'(= 12 (for X (10 20) (T (inc X) (inc @))))
			'(= 120 (mapc * (cdr (1 2 3)) (list 4 5 6) (7 8)))		# 3*5*8
			'(= 120 (mapc (cadr '(foo *)) (2 3) (4 5) (7 8)))		# 3*5*8
			'(= (56 120) (mapcar * (cdr (1 2 3)) (list 4 5 6) (7 8)))
			'(= (56 120) (mapcar (cadr '(foo *)) (2 3) (4 5) (7 8)))
			'(= (0 1 2 3 4 5) (mapcar length '(NIL T 12 "tri" (1 2 3 (a b)) "fi\"ve")))
			'(= (1 2 3) (mapcar (cadr '(foo length)) (list 1 12 123)))
			'(= T (= (mapcar '((S V) (put S 'prop V)) '(A B C) (2 4 6)) (mapcar '((S) (get S 'prop)) '(A B C))))
			'(= (22 11) (let X 11 (list (let (X 22 Y 33) 1 2 X) X)))
			'(= '(a (1 2) b) (str "a (1 2) b"))
			'(= "1 (+ 2 2) 3" (str (1 (+ 2 2) 3)))
			'(= (3 4) (tail (+ 1 1) (cdr (1 2 3 4))))
			'(= 0 (let N 0 (tail 0 (1 2 (inc 'N))) N))
			'(= 0 (let N 0 (tail 2 (1 2 (inc 'N))) N))
			'(= (0 (1 2 (inc 'N))) (let (N 0 L (1 2 (inc 'N))) (tail 0 L) (list N L)))
			'(= '((2 (inc 'N)) 0) (let (N 0 L (1 2 (inc 'N))) (list (tail 2 L) N)))
			'(= (1 2 3) (tail (list 1 2 (+ 1 2)) (0 1 2 3)))
			'(= (0 0) (let (X 0 Y 0) (tail (1 2 (inc 'X)) (0 1 3 (inc 'Y))) (list X Y)))
			'(= (1 0) (let (X 0 Y 0) (tail (list 1 2 (inc 'X)) (0 1 3 (inc 'Y))) (list X Y)))
			'(= '(a ((b c) (1 2 3))) (let S '((a b c) (1 2 3)) (list (pop S) S)))
			'(= '((a b c) ((1 2 3))) (let S '((a b c) (1 2 3)) (list (pop 'S) S)))
			'(= (1 ((a b c) (2 3))) (let S '((a b c) (1 2 3)) (list (pop (cdr S)) S)))
			'(= 2 (pop (list (2 3 4) 5)))
			'(= 2 (pop (2 3 4)))
			'(= NIL (let L NIL (pop 'L)))
			'(= 5 (let N 0 (do (+ 2 3) (inc 'N))))
			'(= 3 (let (N 0 R NIL) (do T (inc 'N) (T (= N 3) (setq R N)))))
			'(= 3 (let (N 0 R NIL) (loop (inc 'N) (T (= N 3) (setq R N)))))
			'(= NIL (while NIL 1))
			'(= 6 (let (N 4 A (or 0)) (while (gt0 (dec 'N)) (inc 'A @))))
			'(= (2 (2)) (let A NIL (list (queue 'A 2) A)))
			'(= (4 (1 2 3 4)) (let A (1 2 3) (list (queue 'A 4) A)))
			'(= (4 ((1 2 3 4) 5)) (let A '((1 2 3) 5) (list (queue A 4) A)))
			'(= '((1 2 3 4) 4) (list (make (link 1 2) (setq S (link 3 4))) S))
			'(= 10 (let (F '+ X 4 Y 2) (apply F (list 3 X) 1 Y)))
			'(= '((apply + (3 4) 1 2) 10) (let (A '(apply + (3 4) 1 2) R (eval A)) (list A R)))
			'(= 27 (apply '((X Y Z) (* X (+ Y Z))) (3 4 5)))
			'(= 15 (let (L (1 2 3) X 4) (apply + L X (+ 2 3))))
			'(= '(NIL 3) (let N 0 (list (+ (inc 'N) (inc 'N) (inc 'N) NIL (inc 'N)) N)))
			'(= '(NIL 4) (let N 0 (list (apply + (list (inc 'N) (inc 'N) (inc 'N) NIL (inc 'N))) N)))
			'(= 1350 ('(@ (pass + 9 8 7)) (+ 2 3) (- 7 1) 1234 (* 9 9)))
			#'(= '(B\C\D^E "B\\C\\D\^E" 7) (let A 'B\\C\\D\^E (list A (pack A) (length A))))
			'(= '("B\\C\\D\^E" "B\\C\\D\^E" 7) (let A "B\\C\\D\^E" (list A (pack A) (length A))))
			'(= '(("B" "\\" "C" "\^" "D") ("B" "\\" "C" "\^" "D")) (list (chop 'B\\C\^D) (chop "B\\C\^D")))
			'(= '(("1" "2" "3") NIL (1 2 3)) (list (chop 123) (chop NIL) (chop (1 2 3))))
			'(= '(NIL 3 3 "X" "Y" 'X 'Y) (let L (3 'Y "Y" 'X 3 "X" NIL) (sort L)))
			'(= '('Y 'X "Y" "X" 3 3 NIL) (let L (3 'Y "Y" 'X 3 "X" NIL) (sort L >)))
			'(= 5 (sort (+ 2 3) 4))
			'(= (3 2 1) (sort (1 2 3) (cadr '(x >))))
			'(= (1111 222 33 4) (sort (33 222 4 1111) '((A B) (> (length A) (length B)))))
			'(= (5 (3 NIL 4) 7) (let I NIL (for X (5 3 7 4 3) (idx 'I X T)) I))
			'(= (5 (3) 7) (let I NIL (for X (5 7 3) (idx 'I X T)) (idx 'I 5)))
			'(= (3 NIL 5) (let I NIL (for X (3 7 5) (idx 'I X 'T)) (idx 'I 7 NIL) I))
			'(= (1 2 3 4 5) (let I NIL (for X (4 5 2 3 1) (idx 'I X T)) (idx 'I)))
			'(= (4 5) (nth (1 2 (3 4 5) 6) 3 2))
			'(= 4 (get (1 2 (3 4 5) 6) 3 2))
			'(= NIL (get (1 2 3) 'foo))
			'(= 2 (prog (put 'X 'p 1) (put 'X 'q 2) (put 'X 't T) (put 'X 'p 11) (get 'X 'q)))
			'(= '(NIL (2 3) (3) NIL) (let L (1 2 3) (list (get L 0) (get L -1) (get L -2) (get L -3))))
			'(= '(NIL (2 3) (3) NIL) (let L (1 2 3) (list (tail 0 L) (tail -1 L) (tail -2 L) (tail -3 L))))
			'(= '((5 . p)) (let (L '(A B C D) C 'E) (put L -1 2 0 'p 5) (getl 'E)))
			'(= 7 (prog (put 'A 'b 'B) (put 'B 'c 7) (; 'A b c)))
			'(= 2	(cond ((= 3 4) 1) ((= 3 3) (setq N 1) (inc N)) (T 3)))
			'(= T (let (L1 (range 1 4) L2 (delete 1 L1)) (== (cdr L1) L2)))
			'(= T (let (L1 (range 1 4) L2 (delete 2 L1)) (== (cddr L1) (cdr L2))))
			'(= '(NIL T) (let (L1 (range 1 4) L2 (delete 9 L1)) (list (== L1 L2) (= L1 L2))))
			'(= (1 2 . 3) (delete 3 (1 2 . 3)))
			'(= (3 two 1) (reverse (1 two 3 . 4)))
			'(= 6 (load "-load \"-* 2 3\""))
			'(= (3 (3 2 1)) (let S NIL (list (push 'S 1 2 (+ 4 -1)) S)))
			'(= '(NIL (NIL)) (let S NIL (list (push 'S) S)))
			'(= '((4 3 . 1) 2) (let L (1 2) (push L 3 4) L))
			'(= "(\"(1 2)\" \"(3 4)\")" (sym (list (sym '(1 2)) (sym '(3 4)))))
			'(= NIL (or))
			'(= NIL (or (= 2 3) (= 3 4)))
			'(= (3 3) (list (or (= 2 3) 3 (= 4 5)) @))
			'(= T (or (= *EMUENV "browser") (= *EMUENV "nodejs") *OS))
			'(= '(3 NIL NIL NIL NIL NIL) (mapcar num? (list (+ 1 2) T NIL '(4 5) 'foo "bar")))
			'(= '(NIL NIL NIL NIL NIL "bar") (mapcar str? (3 T NIL '(4 5) 'foo "bar")))
			
			# circular lists
			'(= 1 (caddr (1 2 .)))
			'(= T (length (1 2 .)))
			
			# curiosities
			'(= 33 ('(22 33)))
			'(= NIL ('(22)))
			) )
	(println 'Tests: (+ Goods Bads) 'Errors: Bads)
	(if (= *EMUENV "browser")
		(= 0 Bads)
		(bye (if (=0 Bads) 0 1)) ) )
