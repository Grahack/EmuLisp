# 26sep14jk

(let (Goods 0 Bads 0)
	(mapc
		'((BoolExpr)
			(if (eval BoolExpr)
				(inc 'Goods)
				(inc 'Bads) (println 'Error: BoolExpr 'Result: (eval (caddr BoolExpr))) ) )
		(list
			'(= '(NIL) (list))
			'(= T (= "abc" "abc"))
			'(= 0 (let N 0 (= 1 2 (inc 'N)) N))
			'(= 0 (let N 0 (== 1 2 (inc 'N)) N))
			'(= -7 (- (+ 3 4)))
			'(= 4 (- (+ 3 4) 2 1))
			'(= (2 -2 2 -2 1 NIL) (list (% 17 5) (% -17 5) (% 17 -5) (% -17 -5) (% 15 10 2) (% 15 NIL 2)))
			'(= 6 (* 1 2 3))
			'(= (1 2 4 8 0) (list (** 2 0) (** 2 1) (** 2 2) (** 2 3) (** 2 'foo)))
			'(= T (< NIL 12 13 'X "Y" (9 9) (9 9 NIL) T))
			'(= T (> T (1 2 (3 . 4)) (1 2 (3)) "Y" 'X 13 12 NIL))
			'(= NIL (< NIL T 12))
			'(= NIL (< 12 14 14))
			'(= T (<= 12 13 13 14 'X 'X 'Y))
			'(= NIL (<= 12 14 13))
			'(= T (<= (usec) (usec)))
			'(= T (<> 2 2 3))
			'(= NIL (<> 2 2 2))
			'(= '(NIL NIL 0 3) (mapcar ge0 (list 'foo -1 (- 2 2) 3)))
			'(= '(NIL NIL 1 3) (mapcar gt0 (list 'foo -1 (- 3 2) 3)))
			'(= '(NIL -1 0 NIL) (mapcar le0 (list 'foo -1 (- 2 2) 3)))
			'(= '(NIL -1 NIL NIL) (mapcar lt0 (list 'foo -1 (- 2 2) 3)))
			'(= '(T T NIL T) (mapcar n0 (list 'foo -1 (- 2 2) 3)))
			'(= '(NIL NIL 0 NIL) (mapcar =0 (list 'foo -1 (- 2 2) 3)))
			'(= NIL (nT (= 2 2)))
			'(= T (nT 0))
			'(= T (=T (= 2 2)))
			'(= NIL (=T 0))
			'(= 0 (prog (zero N) (= 1 2 (inc 'N)) N))
			'(= 0 (prog (zero N) (== 1 2 (inc 'N)) N))
			'(= "1two3T9" (pack 1 "two" (3 T) NIL (+ 4 5)))
			'(= NIL (pack ""))
			'(= 6 (eval (list '+ 1 2 3)))
			'(= '(9 (a 9 c)) (list (set 'L '(a b c) (cdr L) 9) L))
			'(= '(3 3) (list (set (car (str "X")) 3) X))
			'(= '((a b c) b) (let L '(a b c) (list (val 'L) (val (cdr L)))))
			'(= "BCDC" (prog (setq A 'B B 'C C 'D) (pack A B C (eval A))))
			#'(= "BCDC" (let ("A" "B" "B" "C" "C" "D") (pack "A" "B" "C" (eval "A"))))
			'(= "BCDC" (prog (setq "A" '"B" "B" '"C" "C" '"D") (pack "A" "B" "C" (eval "A"))))
			'(= T (prog (setq "A" '"B") (= "A" 'B)))
			'(= 3 (fin (1 2 . 3)))
			'(= NIL (fin (1 2 3)))
			'(= (7 3) (list (if 3 (+ @ 4) 9) @))
			'(= 15 (if 5 (if NIL 88 'dummy1 'dummy2 (+ @ 10)) 99))
			'(= 15 (ifn 5 99 (ifn NIL (+ @ 10) 'dummy1 88)))
			'(= 120 (prog (de fact (N) (if (= 0 N) 1 (* N (fact (- N 1))))) (fact 5)))
			'(= '(a b) (prog (de f1 X (list (car X) (cadr X))) (f1 a b)))
			#'(= (3 7 ((+ 5 6) (+ 7 8))) (prog (de f2 (X Y . Z) (list X Y Z)) (f2 (+ 1 2) (+ 3 4) (+ 5 6) (+ 7 8))))
			'(= 3 (for X (1 2 3 4) (= X 0) (T (= X 3) 'foo X) 'dummy))
			'(= 3 (for X (1 2 3 4) (= X 0) (NIL (not (= X 3)) 'foo X) 'dummy))
			'(= 3 (for (N 1 (not (= N 4)) (inc N)) N))
			'(= (3 13) (for ((I . N) 11 (not (= I 4)) (inc N)) (list I N)))
			'(= (5 4 3 2 1) (make (for (N 1 (<= N 5) (inc N)) (yoke N))))
			'(= 12 (for X (10 20) (T (inc X) (inc @))))
			'(= '((1 2 3) (A B) (2 3) (B) (3) NIL) (make (map link (1 2 3) '(A B))))
			'(= 120 (mapc * (cdr (1 2 3)) (list 4 5 6) (7 8)))		# 3*5*8
			'(= 120 (mapc (cadr '(foo *)) (2 3) (4 5) (7 8)))		# 3*5*8
			'(= (56 120) (mapcar * (cdr (1 2 3)) (list 4 5 6) (7 8)))
			'(= (56 120) (mapcar (cadr '(foo *)) (2 3) (4 5) (7 8)))
			'(= (0 1 2 3 4 5) (mapcar length '(NIL T 12 "tri" (1 2 3 (a b)) "fi\"ve")))
			'(= (1 2 3) (mapcar (cadr '(foo length)) (list 1 12 123)))
			'(= T (= (mapcar '((S V) (put S 'prop V)) '(A B C) (2 4 6)) (mapcar '((S) (get S 'prop)) '(A B C))))
			'(= (22 11) (let X 11 (list (let (X 22 Y 33) 1 2 X) X)))
			'(= '(a (1 2) b) (str "a (1 2) b"))
			'(= "1 (+ 2 2) 3" (str (1 (+ 2 2) 3)))
			'(= '(NIL NIL (a b c) "foo") (mapcar any '("" "()" "(a # Comment^Jb c)" "\"foo\"")))
			'(= (3 4) (tail (+ 1 1) (cdr (1 2 3 4))))
			'(= 0 (let N 0 (tail 0 (1 2 (inc 'N))) N))
			'(= 0 (let N 0 (tail 2 (1 2 (inc 'N))) N))
			'(= (0 (1 2 (inc 'N))) (let (N 0 L (1 2 (inc 'N))) (tail 0 L) (list N L)))
			'(= '((2 (inc 'N)) 0) (let (N 0 L (1 2 (inc 'N))) (list (tail 2 L) N)))
			'(= (1 2 3) (tail (list 1 2 (+ 1 2)) (0 1 2 3)))
			'(= (0 0) (let (X 0 Y 0) (tail (1 2 (inc 'X)) (0 1 3 (inc 'Y))) (list X Y)))
			'(= (1 0) (let (X 0 Y 0) (tail (list 1 2 (inc 'X)) (0 1 3 (inc 'Y))) (list X Y)))
			'(= '(a ((b c) (1 2 3))) (let S '((a b c) (1 2 3)) (list (pop S) S)))
			'(= '((a b c) ((1 2 3))) (let S '((a b c) (1 2 3)) (list (pop 'S) S)))
			'(= (1 ((a b c) (2 3))) (let S '((a b c) (1 2 3)) (list (pop (cdr S)) S)))
			'(= 2 (pop (list (2 3 4) 5)))
			'(= 2 (pop (2 3 4)))
			'(= NIL (let L NIL (pop 'L)))
			'(= 5 (let N 0 (do (+ 2 3) (inc 'N))))
			'(= 3 (let (N 0 R NIL) (do T (inc 'N) (T (= N 3) (setq R N)))))
			'(= 3 (let (N 0 R NIL) (loop (inc 'N) (T (= N 3) (setq R N)))))
			'(= NIL (while NIL 1))
			'(= 6 (let (N 4 A (or 0)) (while (gt0 (dec 'N)) (inc 'A @))))
			'(= (2 (2)) (let A NIL (list (queue 'A 2) A)))
			'(= (4 (1 2 3 4)) (let A (1 2 3) (list (queue 'A 4) A)))
			'(= (4 ((1 2 3 4) 5)) (let A '((1 2 3) 5) (list (queue A 4) A)))
			'(= '((1 2 3 4) 4) (list (make (link 1 2) (setq S (link 3 4))) S))
			'(= (1 (2 3) 4) (make (link 1 (make (link 2 3)) 4)))
			'(= (1 2 3 4 5) (make (link 1) (mapcar link (2 3 4)) (link 5)))
			'(= 10 (let (F '+ X 4 Y 2) (apply F (list 3 X) 1 Y)))
			'(= '((apply + (3 4) 1 2) 10) (let (A '(apply + (3 4) 1 2) R (eval A)) (list A R)))
			'(= 27 (apply '((X Y Z) (* X (+ Y Z))) (3 4 5)))
			'(= 15 (let (L (1 2 3) X 4) (apply + L X (+ 2 3))))
			'(= '(NIL 3) (let N 0 (list (+ (inc 'N) (inc 'N) (inc 'N) NIL (inc 'N)) N)))
			'(= '(NIL 4) (let N 0 (list (apply + (list (inc 'N) (inc 'N) (inc 'N) NIL (inc 'N))) N)))
			'(= '(NIL) (apply list 3))
			'(= '(b c) (apply list 'a 'b 'c))
			'(= (123 123) (apply '(@ (list (next) (arg))) (123)))
			'(= '(NIL T) (let F '(@ (args)) (list (F) (F NIL))))
			'(= 1350 ('(@ (pass + 9 8 7)) (+ 2 3) (- 7 1) 1234 (* 9 9)))
			#'(= '(B\C\D^E "B\\C\\D\^E" 7) (let A 'B\\C\\D\^E (list A (pack A) (length A))))
			'(= '("B\\C\\D\^E" "B\\C\\D\^E" 7) (let A "B\\C\\D\^E" (list A (pack A) (length A))))
			'(= '(("B" "\\" "C" "\^" "D") ("B" "\\" "C" "\^" "D")) (list (chop 'B\\C\^D) (chop "B\\C\^D")))
			'(= "A^JB^MC^IDxE" "A\nB\rC\tD\xE")
			'(= "ABC: â‚¬9.99" "A\66\C: \8364\9.99")
			'(= '(("1" "2" "3") NIL (1 2 3)) (list (chop 123) (chop NIL) (chop (1 2 3))))
			'(= '(NIL 3 3 "X" "Y" 'X 'Y) (let L (3 'Y "Y" 'X 3 "X" NIL) (sort L)))
			'(= '('Y 'X "Y" "X" 3 3 NIL) (let L (3 'Y "Y" 'X 3 "X" NIL) (sort L >)))
			'(= 5 (sort (+ 2 3) 4))
			'(= (4 3 2 1) (sort (1 4 2 3) (cadr '(x >))))
			'(= (1111 222 33 4) (sort (33 222 4 1111) '((A B) (> (length A) (length B)))))
			'(= (5 (3 NIL 4) 7) (let I NIL (for X (5 3 7 4 3) (idx 'I X T)) I))
			'(= (5 (3) 7) (let I NIL (for X (5 7 3) (idx 'I X T)) (idx 'I 5)))
			'(= (3 NIL 5) (let I NIL (for X (3 7 5) (idx 'I X 'T)) (idx 'I 7 NIL) I))
			'(= (1 2 3 4 5) (let I NIL (for X (4 5 2 3 1) (idx 'I X T)) (idx 'I)))
			'(= (4 5) (nth (1 2 (3 4 5) 6) 3 2))
			'(= 4 (get (1 2 (3 4 5) 6) 3 2))
			'(= NIL (get (1 2 3) 'foo))
			'(= 2 (prog (put 'X 'p 1) (put 'X 'q 2) (put 'X 't T) (put 'X 'p 11) (get 'X 'q)))
			'(= '(NIL (2 3) (3) NIL) (let L (1 2 3) (list (get L 0) (get L -1) (get L -2) (get L -3))))
			'(= '(NIL (2 3) (3) NIL) (let L (1 2 3) (list (tail 0 L) (tail -1 L) (tail -2 L) (tail -3 L))))
			'(= '((5 . p)) (let (L '(A B C D) C 'E) (put L -1 2 0 'p 5) (getl 'E)))
			'(= 7 (prog (put 'A 'b 'B) (put 'B 'c 7) (; 'A b c)))
			'(= 2	(cond ((= 3 4) 1) ((= 3 3) (setq N 1) (inc N)) (T 3)))
			'(= T (let (L1 (range 1 4) L2 (delete 1 L1)) (== (cdr L1) L2)))
			'(= T (let (L1 (range 1 4) L2 (delete 2 L1)) (== (cddr L1) (cdr L2))))
			'(= '(NIL T) (let (L1 (range 1 4) L2 (delete 9 L1)) (list (== L1 L2) (= L1 L2))))
			'(= (1 2 . 3) (delete 3 (1 2 . 3)))
			'(= (3 two 1) (reverse (1 two 3 . 4)))
			'(= 6 (load "-load \"-* 2 3\""))
			'(= (3 (3 2 1)) (let S NIL (list (push 'S 1 2 (+ 4 -1)) S)))
			'(= '(NIL (NIL)) (let S NIL (list (push 'S) S)))
			'(= '((4 3 . 1) 2) (let L (1 2) (push L 3 4) L))
			'(= "(\"(1 2)\" \"(3 4)\")" (sym (list (sym '(1 2)) (sym '(3 4)))))
			'(= 4 (and (= 2 2) (= 3 3) 4))
			'(= (3 NIL 3) (list (and (= 2 2) 3) (and) @))
			'(= NIL (or (= 2 3) (= 3 4)))
			'(= (3 NIL 3) (list (or (= 2 3) 3 (= 4 5)) (or) @))
			'(= T (or (= *EMUENV "browser") (= *EMUENV "nodejs") (sym? *OS)))
			'(= '(T T T T T T T T T NIL) (mapcar sym? '(... .1 .1. .1.2 1.2.3 +.1 -.1 1+2 1/2 1.2)))
			'(= '(T T T NIL T T) (mapcar atom (list (or 1 2) T NIL '(4 5) 'foo "bar")))
			'(= '(T T NIL T T T) (mapcar bool (list (or 1 2) T NIL '(4 5) 'foo "bar")))
			'(= '(3 NIL NIL NIL NIL NIL) (mapcar num? (list (+ 1 2) T NIL '(4 5) 'foo "bar")))
			'(= '(NIL NIL NIL NIL NIL "bar") (mapcar str? (3 T NIL '(4 5) 'foo "bar")))
			'(= '(NIL T T NIL NIL T) (mapcar sym? (3 T NIL '(4 5) 'foo "bar")))
			'(= (1814 5 17) (date (date 1814 5 17)))
			'(= (1461 NIL 36524 NIL) (list (date 4 2 29) (date 4 2 30) (date 100 2 28) (date 100 2 29)))
			'(= 3 (num? (cadr (date 1))))
			'(= '(NIL (2 3) NIL (6 7) NIL) (split (range 1 8) 1 4 5 8))
			'(= '((1) (3)) (split (1 2 3) 0 (+ 1 1)))
			'(= '((1 2 3)) (split (1 2 3) 4))
			'(= '("Do" "Re" "Mi") (mapcar pack (split (chop "Do Re Mi") " ")))
			'(= 3 (index '(5 6) '((1 2) (3 4) (5 6) (7 8))))
			'(= NIL (index 33 (11 22 34 .)))
			'(= "7fach" (pre? (+ 3 4) (pack "7f" "ach")))
			'(= 'abcd (pre? "ab" 'abcd))
			'(= NIL (pre? "a" "ba"))
			'(= "abcd" (pre? NIL "abcd"))
			'(= T (pre? T T))
			'(= '(NIL NIL NIL) (need 3))
			'(= '(NIL NIL a b c) (need 5 '(a b c)))
			'(= '(a b c NIL NIL) (need -5 '(a b c)))
			'(= '(x x a b c) (need 5 '(a b c) 'x))
			'(= '(a b c) (need 2 '(a b c)))
			'(= '(a b c) (need -2 '(a b c)))
			'(= (0 0 0 0) (need 4 0))
			'(= 4 ((car '(+)) 2 2))
			'(= 6 (let F '((X Y) (* X Y)) ((car '(F)) 2 3)))
			# The following two pre? tests will fail in Ersatz
			'(= "123" (pre? 12 123))
			'(= "123" (pre? (1 2 3) (1 2 3)))
			# The following two rand tests may theoretically fail
			'(= (-5 9) (let (R NIL Lo T Hi NIL)
				(do 1000 (setq R (rand -5 9)) (if (< R Lo) (setq Lo R)) (if (> R Hi) (setq Hi R))) (list Lo Hi)))
			'(= '(NIL T) (let L () (do 100 (let R (rand T) (ifn (index R L) (setq L (cons R L))))) (sort L)))
			
			# circular lists
			'(= 1 (caddr (1 2 .)))
			'(= T (length (1 2 .)))
			'(= T (length (1 . (2 3 .))))
			'(= 6 (length (1 2 3 1 2 3)))
			
			# objects and classes
			'(= (10 5 30 20 600)
				(let R NIL
					(class +Shape)
					(dm T (X Y) (=: x X) (=: y Y))
					(dm move> (DX DY) (inc (:: x) DX) (inc (:: y) DY))
					(class +Rect +Shape)
					(dm T (X Y DX DY) (super X Y) (=: dx DX) (=: dy DY))
					(dm area> () (* (: dx) (: dy)))
					(setq R (new '(+Rect) 0 0 30 20))
					(try 'move> R 10 5)
					(list (get R 'x) (get R 'y) (get R 'dx) (get R 'dy) (area> R)) ) )
			'(= NIL (try 'msg> 123))

			# todo
			#'(= '((1 2 3 4) (1 2 3 4) (1 2)) (use A B (list (make (link 1 2) (setq A (made) B (copy A)) (link 3 4)) A B)))
			
			# curiosities
			'(= 33 ('(22 33)))
			'(= NIL ('(22)))
			
			#{
				(println "Things inside multi-line comments should be ignored!")
			}#
			) )
	(println 'Tests: (+ Goods Bads) 'Errors: Bads)
	(if (= *EMUENV "browser")
		(= 0 Bads)
		(bye (if (=0 Bads) 0 1)) ) )
